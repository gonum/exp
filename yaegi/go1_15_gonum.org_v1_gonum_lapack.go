// Code generated by 'github.com/containous/yaegi/extract gonum.org/v1/gonum/lapack'. DO NOT EDIT.

// Copyright Â©2019 The Gonum Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build go1.15 && !go1.16
// +build go1.15,!go1.16

package yaegi

import (
	"reflect"

	"gonum.org/v1/gonum/blas"
	"gonum.org/v1/gonum/lapack"
)

func init() {
	Symbols["gonum.org/v1/gonum/lapack"] = map[string]reflect.Value{
		// function, constant and variable definitions
		"ApplyP":              reflect.ValueOf(lapack.ApplyP),
		"ApplyQ":              reflect.ValueOf(lapack.ApplyQ),
		"Backward":            reflect.ValueOf(lapack.Backward),
		"BalanceNone":         reflect.ValueOf(lapack.BalanceNone),
		"Bottom":              reflect.ValueOf(lapack.Bottom),
		"ColumnWise":          reflect.ValueOf(lapack.ColumnWise),
		"EVAll":               reflect.ValueOf(lapack.EVAll),
		"EVAllMulQ":           reflect.ValueOf(lapack.EVAllMulQ),
		"EVBoth":              reflect.ValueOf(lapack.EVBoth),
		"EVCompNone":          reflect.ValueOf(lapack.EVCompNone),
		"EVCompute":           reflect.ValueOf(lapack.EVCompute),
		"EVLeft":              reflect.ValueOf(lapack.EVLeft),
		"EVNone":              reflect.ValueOf(lapack.EVNone),
		"EVOrig":              reflect.ValueOf(lapack.EVOrig),
		"EVRight":             reflect.ValueOf(lapack.EVRight),
		"EVSelected":          reflect.ValueOf(lapack.EVSelected),
		"EVTridiag":           reflect.ValueOf(lapack.EVTridiag),
		"EigenvaluesAndSchur": reflect.ValueOf(lapack.EigenvaluesAndSchur),
		"EigenvaluesOnly":     reflect.ValueOf(lapack.EigenvaluesOnly),
		"Forward":             reflect.ValueOf(lapack.Forward),
		"Frobenius":           reflect.ValueOf(lapack.Frobenius),
		"GSVDNone":            reflect.ValueOf(lapack.GSVDNone),
		"GSVDQ":               reflect.ValueOf(lapack.GSVDQ),
		"GSVDU":               reflect.ValueOf(lapack.GSVDU),
		"GSVDUnit":            reflect.ValueOf(lapack.GSVDUnit),
		"GSVDV":               reflect.ValueOf(lapack.GSVDV),
		"General":             reflect.ValueOf(lapack.General),
		"GeneratePT":          reflect.ValueOf(lapack.GeneratePT),
		"GenerateQ":           reflect.ValueOf(lapack.GenerateQ),
		"LeftEVCompute":       reflect.ValueOf(lapack.LeftEVCompute),
		"LeftEVNone":          reflect.ValueOf(lapack.LeftEVNone),
		"LowerTri":            reflect.ValueOf(lapack.LowerTri),
		"MaxAbs":              reflect.ValueOf(lapack.MaxAbs),
		"MaxColumnSum":        reflect.ValueOf(lapack.MaxColumnSum),
		"MaxRowSum":           reflect.ValueOf(lapack.MaxRowSum),
		"Permute":             reflect.ValueOf(lapack.Permute),
		"PermuteScale":        reflect.ValueOf(lapack.PermuteScale),
		"RightEVCompute":      reflect.ValueOf(lapack.RightEVCompute),
		"RightEVNone":         reflect.ValueOf(lapack.RightEVNone),
		"RowWise":             reflect.ValueOf(lapack.RowWise),
		"SVDAll":              reflect.ValueOf(lapack.SVDAll),
		"SVDNone":             reflect.ValueOf(lapack.SVDNone),
		"SVDOverwrite":        reflect.ValueOf(lapack.SVDOverwrite),
		"SVDStore":            reflect.ValueOf(lapack.SVDStore),
		"Scale":               reflect.ValueOf(lapack.Scale),
		"SchurHess":           reflect.ValueOf(lapack.SchurHess),
		"SchurNone":           reflect.ValueOf(lapack.SchurNone),
		"SchurOrig":           reflect.ValueOf(lapack.SchurOrig),
		"SortDecreasing":      reflect.ValueOf(lapack.SortDecreasing),
		"SortIncreasing":      reflect.ValueOf(lapack.SortIncreasing),
		"Top":                 reflect.ValueOf(lapack.Top),
		"UpdateSchur":         reflect.ValueOf(lapack.UpdateSchur),
		"UpdateSchurNone":     reflect.ValueOf(lapack.UpdateSchurNone),
		"UpperTri":            reflect.ValueOf(lapack.UpperTri),
		"Variable":            reflect.ValueOf(lapack.Variable),

		// type definitions
		"ApplyOrtho":      reflect.ValueOf((*lapack.ApplyOrtho)(nil)),
		"BalanceJob":      reflect.ValueOf((*lapack.BalanceJob)(nil)),
		"Complex128":      reflect.ValueOf((*lapack.Complex128)(nil)),
		"Direct":          reflect.ValueOf((*lapack.Direct)(nil)),
		"EVComp":          reflect.ValueOf((*lapack.EVComp)(nil)),
		"EVHowMany":       reflect.ValueOf((*lapack.EVHowMany)(nil)),
		"EVJob":           reflect.ValueOf((*lapack.EVJob)(nil)),
		"EVSide":          reflect.ValueOf((*lapack.EVSide)(nil)),
		"Float64":         reflect.ValueOf((*lapack.Float64)(nil)),
		"GSVDJob":         reflect.ValueOf((*lapack.GSVDJob)(nil)),
		"GenOrtho":        reflect.ValueOf((*lapack.GenOrtho)(nil)),
		"LeftEVJob":       reflect.ValueOf((*lapack.LeftEVJob)(nil)),
		"MatrixNorm":      reflect.ValueOf((*lapack.MatrixNorm)(nil)),
		"MatrixType":      reflect.ValueOf((*lapack.MatrixType)(nil)),
		"Pivot":           reflect.ValueOf((*lapack.Pivot)(nil)),
		"RightEVJob":      reflect.ValueOf((*lapack.RightEVJob)(nil)),
		"SVDJob":          reflect.ValueOf((*lapack.SVDJob)(nil)),
		"SchurComp":       reflect.ValueOf((*lapack.SchurComp)(nil)),
		"SchurJob":        reflect.ValueOf((*lapack.SchurJob)(nil)),
		"Sort":            reflect.ValueOf((*lapack.Sort)(nil)),
		"StoreV":          reflect.ValueOf((*lapack.StoreV)(nil)),
		"UpdateSchurComp": reflect.ValueOf((*lapack.UpdateSchurComp)(nil)),

		// interface wrapper definitions
		"_Complex128": reflect.ValueOf((*_gonum_org_v1_gonum_lapack_Complex128)(nil)),
		"_Float64":    reflect.ValueOf((*_gonum_org_v1_gonum_lapack_Float64)(nil)),
	}
}

// _gonum_org_v1_gonum_lapack_Complex128 is an interface wrapper for Complex128 type
type _gonum_org_v1_gonum_lapack_Complex128 struct {
}

// _gonum_org_v1_gonum_lapack_Float64 is an interface wrapper for Float64 type
type _gonum_org_v1_gonum_lapack_Float64 struct {
	WDgecon  func(norm lapack.MatrixNorm, n int, a []float64, lda int, anorm float64, work []float64, iwork []int) float64
	WDgeev   func(jobvl lapack.LeftEVJob, jobvr lapack.RightEVJob, n int, a []float64, lda int, wr []float64, wi []float64, vl []float64, ldvl int, vr []float64, ldvr int, work []float64, lwork int) (first int)
	WDgelqf  func(m int, n int, a []float64, lda int, tau []float64, work []float64, lwork int)
	WDgels   func(trans blas.Transpose, m int, n int, nrhs int, a []float64, lda int, b []float64, ldb int, work []float64, lwork int) bool
	WDgeqrf  func(m int, n int, a []float64, lda int, tau []float64, work []float64, lwork int)
	WDgesvd  func(jobU lapack.SVDJob, jobVT lapack.SVDJob, m int, n int, a []float64, lda int, s []float64, u []float64, ldu int, vt []float64, ldvt int, work []float64, lwork int) (ok bool)
	WDgetrf  func(m int, n int, a []float64, lda int, ipiv []int) (ok bool)
	WDgetri  func(n int, a []float64, lda int, ipiv []int, work []float64, lwork int) (ok bool)
	WDgetrs  func(trans blas.Transpose, n int, nrhs int, a []float64, lda int, ipiv []int, b []float64, ldb int)
	WDggsvd3 func(jobU lapack.GSVDJob, jobV lapack.GSVDJob, jobQ lapack.GSVDJob, m int, n int, p int, a []float64, lda int, b []float64, ldb int, alpha []float64, beta []float64, u []float64, ldu int, v []float64, ldv int, q []float64, ldq int, work []float64, lwork int, iwork []int) (k int, l int, ok bool)
	WDlange  func(norm lapack.MatrixNorm, m int, n int, a []float64, lda int, work []float64) float64
	WDlansy  func(norm lapack.MatrixNorm, uplo blas.Uplo, n int, a []float64, lda int, work []float64) float64
	WDlantr  func(norm lapack.MatrixNorm, uplo blas.Uplo, diag blas.Diag, m int, n int, a []float64, lda int, work []float64) float64
	WDlapmt  func(forward bool, m int, n int, x []float64, ldx int, k []int)
	WDormlq  func(side blas.Side, trans blas.Transpose, m int, n int, k int, a []float64, lda int, tau []float64, c []float64, ldc int, work []float64, lwork int)
	WDormqr  func(side blas.Side, trans blas.Transpose, m int, n int, k int, a []float64, lda int, tau []float64, c []float64, ldc int, work []float64, lwork int)
	WDpbcon  func(uplo blas.Uplo, n int, kd int, ab []float64, ldab int, anorm float64, work []float64, iwork []int) float64
	WDpbtrf  func(uplo blas.Uplo, n int, kd int, ab []float64, ldab int) (ok bool)
	WDpbtrs  func(uplo blas.Uplo, n int, kd int, nrhs int, ab []float64, ldab int, b []float64, ldb int)
	WDpocon  func(uplo blas.Uplo, n int, a []float64, lda int, anorm float64, work []float64, iwork []int) float64
	WDpotrf  func(ul blas.Uplo, n int, a []float64, lda int) (ok bool)
	WDpotri  func(ul blas.Uplo, n int, a []float64, lda int) (ok bool)
	WDpotrs  func(ul blas.Uplo, n int, nrhs int, a []float64, lda int, b []float64, ldb int)
	WDsyev   func(jobz lapack.EVJob, uplo blas.Uplo, n int, a []float64, lda int, w []float64, work []float64, lwork int) (ok bool)
	WDtrcon  func(norm lapack.MatrixNorm, uplo blas.Uplo, diag blas.Diag, n int, a []float64, lda int, work []float64, iwork []int) float64
	WDtrtri  func(uplo blas.Uplo, diag blas.Diag, n int, a []float64, lda int) (ok bool)
	WDtrtrs  func(uplo blas.Uplo, trans blas.Transpose, diag blas.Diag, n int, nrhs int, a []float64, lda int, b []float64, ldb int) (ok bool)
}

func (W _gonum_org_v1_gonum_lapack_Float64) Dgecon(norm lapack.MatrixNorm, n int, a []float64, lda int, anorm float64, work []float64, iwork []int) float64 {
	return W.WDgecon(norm, n, a, lda, anorm, work, iwork)
}
func (W _gonum_org_v1_gonum_lapack_Float64) Dgeev(jobvl lapack.LeftEVJob, jobvr lapack.RightEVJob, n int, a []float64, lda int, wr []float64, wi []float64, vl []float64, ldvl int, vr []float64, ldvr int, work []float64, lwork int) (first int) {
	return W.WDgeev(jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, work, lwork)
}
func (W _gonum_org_v1_gonum_lapack_Float64) Dgelqf(m int, n int, a []float64, lda int, tau []float64, work []float64, lwork int) {
	W.WDgelqf(m, n, a, lda, tau, work, lwork)
}
func (W _gonum_org_v1_gonum_lapack_Float64) Dgels(trans blas.Transpose, m int, n int, nrhs int, a []float64, lda int, b []float64, ldb int, work []float64, lwork int) bool {
	return W.WDgels(trans, m, n, nrhs, a, lda, b, ldb, work, lwork)
}
func (W _gonum_org_v1_gonum_lapack_Float64) Dgeqrf(m int, n int, a []float64, lda int, tau []float64, work []float64, lwork int) {
	W.WDgeqrf(m, n, a, lda, tau, work, lwork)
}
func (W _gonum_org_v1_gonum_lapack_Float64) Dgesvd(jobU lapack.SVDJob, jobVT lapack.SVDJob, m int, n int, a []float64, lda int, s []float64, u []float64, ldu int, vt []float64, ldvt int, work []float64, lwork int) (ok bool) {
	return W.WDgesvd(jobU, jobVT, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork)
}
func (W _gonum_org_v1_gonum_lapack_Float64) Dgetrf(m int, n int, a []float64, lda int, ipiv []int) (ok bool) {
	return W.WDgetrf(m, n, a, lda, ipiv)
}
func (W _gonum_org_v1_gonum_lapack_Float64) Dgetri(n int, a []float64, lda int, ipiv []int, work []float64, lwork int) (ok bool) {
	return W.WDgetri(n, a, lda, ipiv, work, lwork)
}
func (W _gonum_org_v1_gonum_lapack_Float64) Dgetrs(trans blas.Transpose, n int, nrhs int, a []float64, lda int, ipiv []int, b []float64, ldb int) {
	W.WDgetrs(trans, n, nrhs, a, lda, ipiv, b, ldb)
}
func (W _gonum_org_v1_gonum_lapack_Float64) Dggsvd3(jobU lapack.GSVDJob, jobV lapack.GSVDJob, jobQ lapack.GSVDJob, m int, n int, p int, a []float64, lda int, b []float64, ldb int, alpha []float64, beta []float64, u []float64, ldu int, v []float64, ldv int, q []float64, ldq int, work []float64, lwork int, iwork []int) (k int, l int, ok bool) {
	return W.WDggsvd3(jobU, jobV, jobQ, m, n, p, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, lwork, iwork)
}
func (W _gonum_org_v1_gonum_lapack_Float64) Dlange(norm lapack.MatrixNorm, m int, n int, a []float64, lda int, work []float64) float64 {
	return W.WDlange(norm, m, n, a, lda, work)
}
func (W _gonum_org_v1_gonum_lapack_Float64) Dlansy(norm lapack.MatrixNorm, uplo blas.Uplo, n int, a []float64, lda int, work []float64) float64 {
	return W.WDlansy(norm, uplo, n, a, lda, work)
}
func (W _gonum_org_v1_gonum_lapack_Float64) Dlantr(norm lapack.MatrixNorm, uplo blas.Uplo, diag blas.Diag, m int, n int, a []float64, lda int, work []float64) float64 {
	return W.WDlantr(norm, uplo, diag, m, n, a, lda, work)
}
func (W _gonum_org_v1_gonum_lapack_Float64) Dlapmt(forward bool, m int, n int, x []float64, ldx int, k []int) {
	W.WDlapmt(forward, m, n, x, ldx, k)
}
func (W _gonum_org_v1_gonum_lapack_Float64) Dormlq(side blas.Side, trans blas.Transpose, m int, n int, k int, a []float64, lda int, tau []float64, c []float64, ldc int, work []float64, lwork int) {
	W.WDormlq(side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork)
}
func (W _gonum_org_v1_gonum_lapack_Float64) Dormqr(side blas.Side, trans blas.Transpose, m int, n int, k int, a []float64, lda int, tau []float64, c []float64, ldc int, work []float64, lwork int) {
	W.WDormqr(side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork)
}
func (W _gonum_org_v1_gonum_lapack_Float64) Dpbcon(uplo blas.Uplo, n int, kd int, ab []float64, ldab int, anorm float64, work []float64, iwork []int) float64 {
	return W.WDpbcon(uplo, n, kd, ab, ldab, anorm, work, iwork)
}
func (W _gonum_org_v1_gonum_lapack_Float64) Dpbtrf(uplo blas.Uplo, n int, kd int, ab []float64, ldab int) (ok bool) {
	return W.WDpbtrf(uplo, n, kd, ab, ldab)
}
func (W _gonum_org_v1_gonum_lapack_Float64) Dpbtrs(uplo blas.Uplo, n int, kd int, nrhs int, ab []float64, ldab int, b []float64, ldb int) {
	W.WDpbtrs(uplo, n, kd, nrhs, ab, ldab, b, ldb)
}
func (W _gonum_org_v1_gonum_lapack_Float64) Dpocon(uplo blas.Uplo, n int, a []float64, lda int, anorm float64, work []float64, iwork []int) float64 {
	return W.WDpocon(uplo, n, a, lda, anorm, work, iwork)
}
func (W _gonum_org_v1_gonum_lapack_Float64) Dpotrf(ul blas.Uplo, n int, a []float64, lda int) (ok bool) {
	return W.WDpotrf(ul, n, a, lda)
}
func (W _gonum_org_v1_gonum_lapack_Float64) Dpotri(ul blas.Uplo, n int, a []float64, lda int) (ok bool) {
	return W.WDpotri(ul, n, a, lda)
}
func (W _gonum_org_v1_gonum_lapack_Float64) Dpotrs(ul blas.Uplo, n int, nrhs int, a []float64, lda int, b []float64, ldb int) {
	W.WDpotrs(ul, n, nrhs, a, lda, b, ldb)
}
func (W _gonum_org_v1_gonum_lapack_Float64) Dsyev(jobz lapack.EVJob, uplo blas.Uplo, n int, a []float64, lda int, w []float64, work []float64, lwork int) (ok bool) {
	return W.WDsyev(jobz, uplo, n, a, lda, w, work, lwork)
}
func (W _gonum_org_v1_gonum_lapack_Float64) Dtrcon(norm lapack.MatrixNorm, uplo blas.Uplo, diag blas.Diag, n int, a []float64, lda int, work []float64, iwork []int) float64 {
	return W.WDtrcon(norm, uplo, diag, n, a, lda, work, iwork)
}
func (W _gonum_org_v1_gonum_lapack_Float64) Dtrtri(uplo blas.Uplo, diag blas.Diag, n int, a []float64, lda int) (ok bool) {
	return W.WDtrtri(uplo, diag, n, a, lda)
}
func (W _gonum_org_v1_gonum_lapack_Float64) Dtrtrs(uplo blas.Uplo, trans blas.Transpose, diag blas.Diag, n int, nrhs int, a []float64, lda int, b []float64, ldb int) (ok bool) {
	return W.WDtrtrs(uplo, trans, diag, n, nrhs, a, lda, b, ldb)
}
