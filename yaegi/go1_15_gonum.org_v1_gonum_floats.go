// Code generated by 'github.com/containous/yaegi/extract gonum.org/v1/gonum/floats'. DO NOT EDIT.

// Copyright Â©2019 The Gonum Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build go1.15,!go1.16

package yaegi

import (
	"reflect"

	"gonum.org/v1/gonum/floats"
)

func init() {
	Symbols["gonum.org/v1/gonum/floats"] = map[string]reflect.Value{
		// function, constant and variable definitions
		"Add":                 reflect.ValueOf(floats.Add),
		"AddConst":            reflect.ValueOf(floats.AddConst),
		"AddScaled":           reflect.ValueOf(floats.AddScaled),
		"AddScaledTo":         reflect.ValueOf(floats.AddScaledTo),
		"AddTo":               reflect.ValueOf(floats.AddTo),
		"Argsort":             reflect.ValueOf(floats.Argsort),
		"Count":               reflect.ValueOf(floats.Count),
		"CumProd":             reflect.ValueOf(floats.CumProd),
		"CumSum":              reflect.ValueOf(floats.CumSum),
		"Distance":            reflect.ValueOf(floats.Distance),
		"Div":                 reflect.ValueOf(floats.Div),
		"DivTo":               reflect.ValueOf(floats.DivTo),
		"Dot":                 reflect.ValueOf(floats.Dot),
		"Equal":               reflect.ValueOf(floats.Equal),
		"EqualApprox":         reflect.ValueOf(floats.EqualApprox),
		"EqualFunc":           reflect.ValueOf(floats.EqualFunc),
		"EqualLengths":        reflect.ValueOf(floats.EqualLengths),
		"EqualWithinAbs":      reflect.ValueOf(&floats.EqualWithinAbs).Elem(),
		"EqualWithinAbsOrRel": reflect.ValueOf(&floats.EqualWithinAbsOrRel).Elem(),
		"EqualWithinRel":      reflect.ValueOf(&floats.EqualWithinRel).Elem(),
		"EqualWithinULP":      reflect.ValueOf(&floats.EqualWithinULP).Elem(),
		"Find":                reflect.ValueOf(floats.Find),
		"HasNaN":              reflect.ValueOf(floats.HasNaN),
		"LogSpan":             reflect.ValueOf(floats.LogSpan),
		"LogSumExp":           reflect.ValueOf(floats.LogSumExp),
		"Max":                 reflect.ValueOf(floats.Max),
		"MaxIdx":              reflect.ValueOf(floats.MaxIdx),
		"Min":                 reflect.ValueOf(floats.Min),
		"MinIdx":              reflect.ValueOf(floats.MinIdx),
		"Mul":                 reflect.ValueOf(floats.Mul),
		"MulTo":               reflect.ValueOf(floats.MulTo),
		"NaNPayload":          reflect.ValueOf(&floats.NaNPayload).Elem(),
		"NaNWith":             reflect.ValueOf(&floats.NaNWith).Elem(),
		"NearestIdx":          reflect.ValueOf(floats.NearestIdx),
		"NearestIdxForSpan":   reflect.ValueOf(floats.NearestIdxForSpan),
		"Norm":                reflect.ValueOf(floats.Norm),
		"ParseWithNA":         reflect.ValueOf(&floats.ParseWithNA).Elem(),
		"Prod":                reflect.ValueOf(floats.Prod),
		"Reverse":             reflect.ValueOf(floats.Reverse),
		"Round":               reflect.ValueOf(&floats.Round).Elem(),
		"RoundEven":           reflect.ValueOf(&floats.RoundEven).Elem(),
		"Same":                reflect.ValueOf(floats.Same),
		"Scale":               reflect.ValueOf(floats.Scale),
		"ScaleTo":             reflect.ValueOf(floats.ScaleTo),
		"Span":                reflect.ValueOf(floats.Span),
		"Sub":                 reflect.ValueOf(floats.Sub),
		"SubTo":               reflect.ValueOf(floats.SubTo),
		"Sum":                 reflect.ValueOf(floats.Sum),
		"SumCompensated":      reflect.ValueOf(floats.SumCompensated),
		"Within":              reflect.ValueOf(floats.Within),
	}
}
