// Copyright ©2013 The bíogo Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package rings

import (
	"flag"
	"fmt"
	"image/color"
	"math/rand"
	"reflect"
	"testing"

	"gonum.org/v1/plot"
	"gonum.org/v1/plot/vg"
	"gonum.org/v1/plot/vg/draw"

	"github.com/biogo/biogo/feat"
)

var pics = flag.Bool("pic", false, "Show the graphics generated by failing tests.")
var allPics = flag.Bool("allpic", false, "Show the graphics generated by all tests.")

func failure(f bool) string {
	if f {
		return "fail"
	}
	return "ok"
}

// fs is a feat.Feature implementation for testing.
type fs struct {
	start, end int
	name       string
	location   feat.Feature
	orient     feat.Orientation
	style      draw.LineStyle
	scores     []float64
}

func (f *fs) Start() int                    { return f.start }
func (f *fs) End() int                      { return f.end }
func (f *fs) Len() int                      { return f.end - f.start }
func (f *fs) Name() string                  { return f.name }
func (f *fs) Description() string           { return "bogus" }
func (f *fs) Location() feat.Feature        { return f.location }
func (f *fs) Orientation() feat.Orientation { return f.orient }
func (f *fs) LineStyle() draw.LineStyle     { return f.style }
func (f *fs) Scores() []float64             { return f.scores }

type fp struct {
	feats [2]*fs
	sty   draw.LineStyle
}

func (p fp) Features() [2]feat.Feature { return [2]feat.Feature{p.feats[0], p.feats[1]} }
func (p fp) LineStyle() draw.LineStyle {
	var col color.RGBA
	for _, f := range p.feats {
		r, g, b, a := f.style.Color.RGBA()
		col.R += byte(r / 2)
		col.G += byte(g / 2)
		col.B += byte(b / 2)
		col.A += byte(a / 2)
	}
	p.sty.Color = col
	return p.sty
}

func randomFeatures(n, min, max int, single bool, sty draw.LineStyle) []feat.Feature {
	data := make([]feat.Feature, n)
	for i := range data {
		start := rand.Intn(max-min) + min
		var end int
		if !single {
			end = rand.Intn(max - start)
		}
		data[i] = &fs{
			start: start,
			end:   start + end,
			name:  fmt.Sprintf("feature%v", i),
			style: sty,
		}
	}
	return data
}

func floatPtr(f float64) *float64 { return &f }

// makeScorers returns n Scorers each with m scores.
func makeScorers(f *fs, n, m int, fn func(i, j int) float64) []Scorer {
	s := make([]Scorer, n)
	for i := 0; i < n; i++ {
		cs := &fs{
			start:    f.Start() + i*(f.Len()/n),
			end:      f.Start() + (i+1)*(f.Len()/n),
			name:     fmt.Sprintf("%s#%d", f.Name(), i),
			location: f,
			scores:   make([]float64, m),
		}
		for j := range cs.scores {
			cs.scores[j] = fn(i, j)
		}
		s[i] = cs
	}
	return s
}

// base represents the common output from a gonum/plot plot draw operation.
var base = newCanvas(
	72,
	[]interface{}{
		setColor{col: color.Gray16{Y: 0xffff}},
		fill{path: vg.Path{
			{Type: vg.MoveComp, Pos: vg.Point{X: 0, Y: 0}, Radius: 0, Start: 0, Angle: 0},
			{Type: vg.LineComp, Pos: vg.Point{X: 300, Y: 0}, Radius: 0, Start: 0, Angle: 0},
			{Type: vg.LineComp, Pos: vg.Point{X: 300, Y: 300}, Radius: 0, Start: 0, Angle: 0},
			{Type: vg.LineComp, Pos: vg.Point{X: 0, Y: 300}, Radius: 0, Start: 0, Angle: 0},
			{Type: vg.CloseComp, Pos: vg.Point{X: 0, Y: 0}, Radius: 0, Start: 0, Angle: 0},
		}},
		setColor{col: color.Gray16{Y: 0x0}},
		setWidth{w: 0},
		setLineDash{dashes: []vg.Length(nil), offsets: 0},
		stroke{path: vg.Path{
			{Type: vg.MoveComp, Pos: vg.Point{X: 5, Y: 0}, Radius: 0, Start: 0, Angle: 0},
			{Type: vg.LineComp, Pos: vg.Point{X: 300, Y: 0}, Radius: 0, Start: 0, Angle: 0},
		}},
		setColor{col: color.Gray16{Y: 0x0}},
		setWidth{w: 0},
		setLineDash{dashes: []vg.Length(nil), offsets: 0},
		stroke{path: vg.Path{
			{Type: vg.MoveComp, Pos: vg.Point{X: 0, Y: 5}, Radius: 0, Start: 0, Angle: 0},
			{Type: vg.LineComp, Pos: vg.Point{X: 0, Y: 300}, Radius: 0, Start: 0, Angle: 0},
		}},
	},
)

func TestNew(t *testing.T) {
	p, err := plot.New()
	if err != nil {
		t.Errorf("unexpected error for plot.New(): %v", err)
	}

	p.HideAxes()

	tc := &canvas{dpi: defaultDPI}
	p.Draw(draw.NewCanvas(tc, 300, 300))

	base.append()
	if !reflect.DeepEqual(tc.actions, base.actions) {
		t.Errorf("unexpected base actions:\ngot :%#v\nwant:%#v", tc.actions, base.actions)
	}
}
