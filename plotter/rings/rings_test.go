// Copyright ©2013 The bíogo Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package rings

import (
	"bytes"
	"flag"
	"fmt"
	"image"
	"image/color"
	"io/ioutil"
	"math/rand"
	"path/filepath"
	"reflect"
	"testing"

	"gonum.org/v1/plot"
	"gonum.org/v1/plot/vg"
	"gonum.org/v1/plot/vg/draw"
)

var pics = flag.Bool("pic", false, "Show the graphics generated by failing tests.")
var allPics = flag.Bool("allpic", false, "Show the graphics generated by all tests.")

func failure(f bool) string {
	if f {
		return "fail"
	}
	return "ok"
}

// fs is a Feature implementation for testing.
type fs struct {
	start, end int
	name       string
	location   Feature
	orient     Orientation
	style      draw.LineStyle
	scores     []float64
}

func (f *fs) Start() int                { return f.start }
func (f *fs) End() int                  { return f.end }
func (f *fs) Name() string              { return f.name }
func (f *fs) Location() Feature         { return f.location }
func (f *fs) Orientation() Orientation  { return f.orient }
func (f *fs) LineStyle() draw.LineStyle { return f.style }
func (f *fs) Scores() []float64         { return f.scores }

type fp struct {
	feats [2]*fs
	sty   draw.LineStyle
}

func (p fp) Features() [2]Feature { return [2]Feature{p.feats[0], p.feats[1]} }
func (p fp) LineStyle() draw.LineStyle {
	var col color.RGBA
	for _, f := range p.feats {
		r, g, b, a := f.style.Color.RGBA()
		col.R += byte(r / 2)
		col.G += byte(g / 2)
		col.B += byte(b / 2)
		col.A += byte(a / 2)
	}
	p.sty.Color = col
	return p.sty
}

func randomFeatures(n, min, max int, single bool, sty draw.LineStyle) []Feature {
	data := make([]Feature, n)
	for i := range data {
		start := rand.Intn(max-min) + min
		var end int
		if !single {
			end = rand.Intn(max - start)
		}
		data[i] = &fs{
			start: start,
			end:   start + end,
			name:  fmt.Sprintf("feature%v", i),
			style: sty,
		}
	}
	return data
}

func floatPtr(f float64) *float64 { return &f }

// makeScorers returns n Scorers each with m scores.
func makeScorers(f *fs, n, m int, fn func(i, j int) float64) []Scorer {
	s := make([]Scorer, n)
	for i := 0; i < n; i++ {
		cs := &fs{
			start:    f.Start() + i*(lengthOf(f)/n),
			end:      f.Start() + (i+1)*(lengthOf(f)/n),
			name:     fmt.Sprintf("%s#%d", f.Name(), i),
			location: f,
			scores:   make([]float64, m),
		}
		for j := range cs.scores {
			cs.scores[j] = fn(i, j)
		}
		s[i] = cs
	}
	return s
}

// base represents the common output from a gonum/plot plot draw operation.
var base = newCanvas(
	72,
	[]interface{}{
		setColor{col: color.Gray16{Y: 0xffff}},
		fill{path: vg.Path{
			{Type: vg.MoveComp, Pos: vg.Point{X: 0, Y: 0}, Radius: 0, Start: 0, Angle: 0},
			{Type: vg.LineComp, Pos: vg.Point{X: 300, Y: 0}, Radius: 0, Start: 0, Angle: 0},
			{Type: vg.LineComp, Pos: vg.Point{X: 300, Y: 300}, Radius: 0, Start: 0, Angle: 0},
			{Type: vg.LineComp, Pos: vg.Point{X: 0, Y: 300}, Radius: 0, Start: 0, Angle: 0},
			{Type: vg.CloseComp, Pos: vg.Point{X: 0, Y: 0}, Radius: 0, Start: 0, Angle: 0},
		}},
		setColor{col: color.Gray16{Y: 0x0}},
		setWidth{w: 0},
		setLineDash{dashes: []vg.Length(nil), offsets: 0},
		stroke{path: vg.Path{
			{Type: vg.MoveComp, Pos: vg.Point{X: 5, Y: 0}, Radius: 0, Start: 0, Angle: 0},
			{Type: vg.LineComp, Pos: vg.Point{X: 300, Y: 0}, Radius: 0, Start: 0, Angle: 0},
		}},
		setColor{col: color.Gray16{Y: 0x0}},
		setWidth{w: 0},
		setLineDash{dashes: []vg.Length(nil), offsets: 0},
		stroke{path: vg.Path{
			{Type: vg.MoveComp, Pos: vg.Point{X: 0, Y: 5}, Radius: 0, Start: 0, Angle: 0},
			{Type: vg.LineComp, Pos: vg.Point{X: 0, Y: 300}, Radius: 0, Start: 0, Angle: 0},
		}},
	},
)

func TestNew(t *testing.T) {
	p, err := plot.New()
	if err != nil {
		t.Errorf("unexpected error for plot.New(): %v", err)
	}

	p.HideAxes()

	tc := &canvas{dpi: defaultDPI}
	p.Draw(draw.NewCanvas(tc, 300, 300))

	base.append()
	if !reflect.DeepEqual(tc.actions, base.actions) {
		t.Errorf("unexpected base actions:\ngot :%#v\nwant:%#v", tc.actions, base.actions)
	}
}

// checkImage compares the plot in p to the image in testdata/name_golden.png.
// If regen is true the plot in p is first saved to testdata/name_golden.png.
func checkImage(t *testing.T, name string, p *plot.Plot, regen bool) {
	path := filepath.Join("testdata", name+"_golden.png")
	w, err := p.WriterTo(vg.Length(300), vg.Length(300), "png")
	var buf bytes.Buffer
	_, err = w.WriteTo(&buf)
	if err != nil {
		t.Fatalf("unexpected error writing plot: %v", err)
	}
	got := buf.Bytes()
	if regen {
		err = ioutil.WriteFile(path, got, 0664)
		if err != nil {
			t.Fatalf("unexpected error writing golden file: %v", err)
		}
		// Fallthrough rather than returning just
		// to confirm we have written correctly.
	}
	gold, err := ioutil.ReadFile(path)
	if err != nil {
		t.Fatalf("unexpected error reading golden file: %v", err)
	}
	ok, err := equalImage(got, gold)
	if err != nil {
		t.Errorf("failed to compare image for %s: %v", path, err)
	}
	if !ok {
		t.Errorf("image mismatch for %q", name)
		// TODO(kortschak): Add image diffing.
		err = ioutil.WriteFile(filepath.Join("testdata", name+"_failed.png"), got, 0664)
		if err != nil {
			t.Fatalf("unexpected error writing failed file: %v", err)
		}
	}
}

// TODO(kortschak): Use cmpimg when rings lives in plot.
func equalImage(raw1, raw2 []byte) (bool, error) {
	v1, _, err := image.Decode(bytes.NewReader(raw1))
	if err != nil {
		return false, err
	}
	v2, _, err := image.Decode(bytes.NewReader(raw2))
	if err != nil {
		return false, err
	}
	return reflect.DeepEqual(v1, v2), nil
}
